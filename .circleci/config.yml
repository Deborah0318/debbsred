#include <msp430.h>
#include "LiquidCrystal_I2C.h"
void main(void){
 WDTCTL = WDTPW | WDTHOLD; // Stop WatchDog Timer
//UART configuration
 UCA1CTLW0 |= UCSWRST; // eUSCI reset to append
 UCA1CTLW0 |= UCSSEL__ACLK; // ACLK = 32Mhz
//UART pins configure, connect Rx > Tx and Tx > Rx for dual way connections and communication (HC-05)
 P4SEL1 &= ~BIT2; //Sets value to 0
 P4SEL0 |= BIT2; //Sets value to 1
//Baud rate calculation = 9600 for HC-05
 UCA1BR0 = 3; // 32768/9600 - int(32768/9600) = 0.167
 UCA1MCTLW = 0x9200; //UCBRSx Value = 0x92
//PWM output configuration for driving the motor
 P6DIR |= BIT1; //P6.1 output
 P6SEL0 |= BIT1; //P6.1 options select (TB3.2)
//setup timer 3 B CCR
 TB3CCR0 = 328; //We are using 100 Hz for the PWM
 TB3CCTL2 = OUTMOD_7;
 TB3CCR2 = 0; //For one motor
//Configuration for Timer3_B
 TB3CTL = TBSSEL_1 | MC_1 | TBCLR; // ACLK, up mode, clear TBR
 P1DIR |= BIT1; //Sets up P1.1 for output
 P1OUT &= ~BIT1; //Clears P1.1
 PM5CTL0 &= ~LOCKLPM5; //Unlocks input and outputs
5 | P a g e
 UCA1CTLW0 &= ~UCSWRST; //Initializes eUSCI and sets the value to zero
 UCA1IE |= UCRXIE; //Configures Interrupt behaviour
 __enable_interrupt();
//Setting ports = 0 initially
 P1OUT = 0x00;
//LCD setup screen for initialization
 I2C_Init(0x27);//Defines Screen Size
 LCD_Setup();//Initialized the Screen to start
 LCD_ClearDisplay();//Clears the Display
 LCD_SetCursor(0,0);//Sets the cursor location to the top left portion
 LCD_Write("Final Project");//Initial LCD Message on load up
 while(1){
 __bis_SR_register(LPM0_bits);
 }
}
//Sets up the initial interrupt loop that works with the bluetooth input and the motor/lcd outputs
#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
 if(UCA1RXBUF == 'u'){ //By sending 'u' in the bluetooth controls, the value of the speed is indexed up.
 P1OUT += 5; //Adjusts the output value by adding five to the initial/current value
 }
 else if(UCA1RXBUF == 'd'){ //By sending 'd' in the bluetooth controls, the value of the speed is indexed
down.
 P1OUT -= 5; //Adjusts the output value by removing five from the initial/current value
 }
 if(P1OUT == 0x00){ //Checking the UART buffer by hex value, not dec!!!!, 0 speed settings
 I2C_Init(0x27); //Defines screen size
6 | P a g e
 LCD_SetCursor(0,0);//Sets cursor location
 LCD_Write("Speed: 0%");//What is displayed
 TB3CCR2 = 0;//Calculated value for the PWM to be set to
 //All of these comments apply to the following else if statements and all do the same job
 }
 else if(P1OUT >= 0x05 && P1OUT < 0x0A){ //5 to 10 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 5%");
 TB3CCR2 = 15;
 }
 else if(P1OUT >= 0x0A && P1OUT < 0x0F){ //10 to 15 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 10%");
 TB3CCR2 = 30;
 }
 else if(P1OUT >= 0x0F && P1OUT < 0x14){ //15 to 20 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 15%");
 TB3CCR2 = 45;
 }
 else if(P1OUT >= 0x14 && P1OUT < 0x19){ //20 to 25 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 20%");
 TB3CCR2 = 60;
7 | P a g e
 }
 else if(P1OUT >= 0x19 && P1OUT < 0x1E){ //25 to 30 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 25%");
 TB3CCR2 = 75;
 }
 else if(P1OUT >= 0x1E && P1OUT < 0x23){ //30 to 35 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 30%");
 TB3CCR2 = 90;
 }
 else if(P1OUT >= 0x23 && P1OUT < 0x28){ //35 to 40 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 35%");
 TB3CCR2 = 105;
 }
 else if(P1OUT >= 0x28 && P1OUT < 0x2D){ //40 to 45 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 40% ");
 TB3CCR2 = 120;
 }
 else if(P1OUT >= 0x2D && P1OUT < 0x32){ //45 to 50 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
8 | P a g e
 LCD_Write("Speed: 45% ");
 TB3CCR2 = 135;
 }
 else if(P1OUT >= 0x32 && P1OUT < 0x37){ //50 to 55 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 50% ");
 TB3CCR2 = 150;
 }
 else if(P1OUT >= 0x37 && P1OUT < 0x3C){ //55 to 60 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 55% ");
 TB3CCR2 = 165;
 }
 else if(P1OUT >= 0x3C && P1OUT < 0x41){ //60 to 65 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 60% ");
 TB3CCR2 = 180;
 }
 else if(P1OUT >= 0x41 && P1OUT < 0x46){ //65 to 70 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 65% ");
 TB3CCR2 = 195;
 }
 else if(P1OUT >= 0x46 && P1OUT < 0x4B){ //70 to 75 speed settings
9 | P a g e
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 70% ");
 TB3CCR2 = 210;
 }
 else if(P1OUT >= 0x4B && P1OUT < 0x50){ //75 to 80 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 75% ");
 TB3CCR2 = 225;
 }
 else if(P1OUT >= 0x50 && P1OUT < 0x55){ //80 to 85 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 80% ");
 TB3CCR2 = 240;
 }
 else if(P1OUT >= 0x55 && P1OUT < 0x5A){ //85 to 90 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 85% ");
 TB3CCR2 = 255;
 }
 else if(P1OUT >= 0x5A && P1OUT < 0x5F){ //90 to 95 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 90% ");
 TB3CCR2 = 270;
10 | P a g e
 }
 else if(P1OUT >= 0x5F && P1OUT < 0x64){ //95 to 100 speed settings
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 95% ");
 TB3CCR2 = 295;
 }
 else if(P1OUT >= 0x64 && P1OUT < 0x69){ //100 to 105 speed settings (allows us to reach 100 percent of
the speed allocated to the motor with our designated PWM)
 I2C_Init(0x27);
 LCD_SetCursor(0,0);
 LCD_Write("Speed: 100% ");
 TB3CCR2 = 310;
 }
 else if(P1OUT >= 0x6E){ //105 to 110, Maxs out the motor speed, the ascii value will not be reached and will
cause the motor to turn off
 P1OUT = 0x00;
 }
}